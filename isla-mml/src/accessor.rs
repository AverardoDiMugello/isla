// BSD 2-Clause License
//
// Copyright (c) 2022 Alasdair Armstrong
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//! Accessors are paths into the events generated by Isla in a
//! trace. An Isla event may contain arbitrary data provided by the
//! Sail model, so we need some way to access that data from the SMT
//! memory model.

use std::borrow::Borrow;
use std::collections::HashMap;

use isla_lib::bitvector::BV;
use isla_lib::log;
use isla_lib::ir::{DebugInfo, SharedState, Val};
use isla_lib::smt::{Event, smtlib::Ty};

use crate::memory_model::{Accessor, Name, Symtab};
use crate::smt::{Sexp, SexpArena, SexpId};

pub trait ModelEvent<'ev, B> {
    fn name(&self) -> Name;

    fn base_events(&self) -> &[&'ev Event<B>];

    fn base(&self) -> Option<&'ev Event<B>> {
        match self.base_events() {
            &[ev] => Some(ev),
            _ => None,
        }
    }
}

#[derive(Debug)]
pub enum AccessorTree<'a> {
    Node { elem: &'a Accessor, child: Box<AccessorTree<'a>> },
    Match { arms: HashMap<Option<Name>, AccessorTree<'a>> },
    Leaf,
}

impl<'a> AccessorTree<'a> {
    pub fn from_accessors(accessors: &'a [Accessor]) -> Self {
        let mut constructor_stack = Vec::new();
        let mut cur = AccessorTree::Leaf;

        for accessor in accessors {
            match accessor {
                Accessor::Ctor(ctor) => {
                    constructor_stack.push((Some(*ctor), cur));
                    cur = AccessorTree::Leaf
                }
                Accessor::Wildcard => {
                    constructor_stack.push((None, cur));
                    cur = AccessorTree::Leaf
                }
                Accessor::Match(n) => {
                    let mut arms = constructor_stack.split_off(constructor_stack.len() - n);
                    cur = AccessorTree::Match { arms: arms.drain(..).collect() }
                }
                acc => cur = AccessorTree::Node { elem: acc, child: Box::new(cur) },
            }
        }

        assert!(constructor_stack.is_empty());

        cur
    }
}

#[derive(Copy, Clone, Debug)]
enum View<'ev, B> {
    Val(&'ev Val<B>),
    Sexp(SexpId),
}

impl<'ev, B: BV> View<'ev, B> {
    fn to_sexp(&self, sexps: &mut SexpArena) -> Option<SexpId> {
        Some(match self {
            View::Sexp(id) => *id,
            View::Val(v) => match v {
                Val::Bool(true) => sexps.bool_true,
                Val::Bool(false) => sexps.bool_false,
                Val::Bits(bv) => sexps.alloc(Sexp::Bits(bv.to_vec())),
                Val::Symbolic(v) => sexps.alloc(Sexp::Symbolic(*v)),
                _ => return None,
            },
        })
    }
}

// This type represents the view into an event as we walk down into it.
enum EventView<'ev, B> {
    ReadMem { address: &'ev Val<B>, data: &'ev Val<B>, value: &'ev Val<B> },
    WriteMem { address: &'ev Val<B>, data: &'ev Val<B>, value: &'ev Val<B> },
    Abstract { values: &'ev [Val<B>], return_value: &'ev Val<B> },
    Other { value: View<'ev, B> },
    Default,
}

impl<'ev, B: BV> EventView<'ev, B> {
    fn view(&self) -> Option<View<'ev, B>> {
        use EventView::*;
        match self {
            ReadMem { value, .. } => Some(View::Val(value)),
            WriteMem { value, .. } => Some(View::Val(value)),
            Abstract { values, .. } => if values.len() == 1 {
                Some(View::Val(&values[0]))
            } else {
                None
            },
            Other { value } => Some(*value),
            Default => None,
        }
    }
    
    fn other(&mut self) -> &mut Self {
        use EventView::*;
        match self {
            ReadMem { value, .. } => *self = Other { value: View::Val(value) },
            WriteMem { value, .. } => *self = Other { value: View::Val(value) },
            Abstract { values, .. } => if values.len() == 1 {
                *self = Other { value: View::Val(&values[0]) }
            },
            _ => (),
        };
        self
    }
    
    fn access_address(&mut self) {
        use EventView::*;
        match self {
            ReadMem { address, .. } => *self = Other { value: View::Val(address) },
            WriteMem { address, .. } => *self = Other { value: View::Val(address) },
            _ => *self = Default,
        }
    }

    fn access_data(&mut self) {
        use EventView::*;
        match self {
            ReadMem { data, .. } => *self = Other { value: View::Val(data) },
            WriteMem { data, .. } => *self = Other { value: View::Val(data) },
            _ => *self = Default,
        }
    }

    fn access_field(&mut self, field: Name, symtab: &Symtab, debug_info: &DebugInfo) {
        use EventView::*;
        if let Some(sym) = symtab.get(field) {
            if let Other { value: View::Val(Val::Struct(fields)) } = self.other() {
                for (field_name, field_value) in fields {
                    if debug_info.mangled_names.get(field_name).map(String::as_ref) == Some(sym) {
                        *self = Other { value: View::Val(field_value) };
                        return
                    }
                }
            }
        }
        *self = Default
    }

    fn access_tuple(&mut self, n: usize, debug_info: &DebugInfo) {
        use EventView::*;
        if let Abstract { values, .. } = self {
            *self = Other { value: View::Val(&values[n]) };
            return;
        } else if let Other { value: View::Val(Val::Struct(fields)) } = self.other() {
            for (name, field_value) in fields.iter() {
                if debug_info.tuple_struct_field_number(*name) == Some(n) {
                    *self = Other { value: View::Val(field_value) };
                    return;
                }
            }
        }
        *self = Default
    }

    fn access_match<'a, 'b, 'c>(&'a mut self, arms: &'b HashMap<Option<Name>, AccessorTree<'c>>, symtab: &Symtab, debug_info: &DebugInfo) -> &'b AccessorTree<'c> {
        use EventView::*;

        match self.other() {
            Other { value: View::Val(Val::Ctor(ctor_name, value)) } => {
                if let Some(ctor_name) = debug_info.mangled_names.get(ctor_name).map(String::as_ref) {
                    *self = Other { value: View::Val(value) };
                    return &arms[&symtab.lookup(ctor_name)];
                } else {
                    panic!("Failed to demangle constructor")
                }
            }
            
            _ => (),
        }

        *self = Default;
        &arms[&None]
    }
}

fn generate_ite_chain<'ev, B: BV>(
    event_values: &HashMap<Name, (EventView<'ev, B>, &AccessorTree)>,
    ty: &Ty,
    sexps: &mut SexpArena,
) -> SexpId {
    let mut chain = sexps.alloc_default_value(ty);
    
    for (ev, (event_view, _)) in event_values {
        let result = event_view.view().and_then(|v| v.to_sexp(sexps));
        if let Some(id) = result {
            let ev = sexps.alloc(Sexp::Atom(*ev));
            let comparison = sexps.alloc(Sexp::List(vec![sexps.eq, ev, sexps.ev1]));
            chain = sexps.alloc(Sexp::List(vec![sexps.ite, comparison, id, chain]))
        }
    }

    chain
}

pub fn generate_accessor_function<'ev, B: BV, E: ModelEvent<'ev, B>, V: Borrow<E>>(
    accessor_fn: Name,
    accessors: &[Accessor],
    events: &[V],
    shared_state: &SharedState<B>,
    symtab: &Symtab,
    sexps: &mut SexpArena,
) -> SexpId {
    use Accessor::*;

    let acctree = &AccessorTree::from_accessors(accessors);

    let mut event_values: HashMap<Name, (EventView<'ev, B>, &AccessorTree)> = HashMap::new();

    for event in events {
        let name = event.borrow().name();
        match event.borrow().base() {
            None => {
                event_values.insert(name, (EventView::Default, acctree));
            }
            Some(ev) => match ev {
                Event::ReadMem { address, value, read_kind, .. } => {
                    event_values.insert(name, (EventView::ReadMem { address, data: value, value: read_kind }, acctree));
                }
                Event::WriteMem { address, data, write_kind, .. } => {
                    event_values.insert(name, (EventView::WriteMem { address, data, value: write_kind }, acctree));
                }
                Event::Abstract { name: _, primitive, args, return_value } => if *primitive {
                    event_values.insert(name, (EventView::Abstract { values: args, return_value }, acctree));
                }
                Event::ReadReg(_, _, value) => {
                    event_values.insert(name, (EventView::Other { value: View::Val(value) }, acctree));
                }
                Event::WriteReg(_, _, value) => {
                    event_values.insert(name, (EventView::Other { value: View::Val(value) }, acctree));
                }
                _ => (),
            },
        }
    }

    for (view, acctree) in event_values.values_mut() {
        loop {
            log!(log::LITMUS, &format!("{:?}", acctree));
            match acctree {
                AccessorTree::Node { elem, child } => {
                    match elem {
                        Extz(_n) => (),
                        Exts(_n) => (),
                        Subvec(_hi, _lo) => (),
                        Tuple(n) => view.access_tuple(*n, &shared_state.debug_info),
                        Bits(_bitvec) => (),
                        Field(name) => view.access_field(*name, symtab, &shared_state.debug_info),
                        Length(_n) => (),
                        Address => view.access_address(),
                        Data => view.access_data(),

                        // Should not occur as an accessortree node
                        Ctor(_) | Wildcard | Match(_) => unreachable!(),
                    }
                    *acctree = child
                }
                AccessorTree::Match { arms } => {
                    let child = view.access_match(arms, symtab, &shared_state.debug_info);
                    *acctree = child
                }
                AccessorTree::Leaf => break,
            }
        }
    }

    let accessor_param = sexps.alloc(Sexp::List(vec![sexps.ev1, sexps.event]));
    let accessor_params = sexps.alloc(Sexp::List(vec![accessor_param]));
    let accessor_ty = sexps.alloc_ty(&Ty::BitVec(64));
    let accessor_ite = generate_ite_chain(&event_values, &Ty::BitVec(64), sexps);
    
    let accessor_fn = sexps.alloc(Sexp::Atom(accessor_fn));
    sexps.alloc(Sexp::List(vec![sexps.define_fun, accessor_fn, accessor_params, accessor_ty, accessor_ite]))
}
