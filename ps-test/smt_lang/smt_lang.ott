
% experimental Ott grammar for the symbolic output of isla-footprint, based on the Rust isla-lib/srf/smt.rs types

metavar u32 ::= {{ ocaml int}} {{ lex numeric }} {{ ocamllex ['0'-'9']* }} {{ pp x = string (string_of_int x) }} {{ pp-raw x = string (string_of_int x) }}
metavar vu32 ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex 'v'['0'-'9']* }}
metavar u64 ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex ['0'-'9']* }}
%metavar Vec_bool ::= {{ ocaml string}} {{ lex alphanum}} {{ ocamllex ['0'-'9''a'-'f'] }}

metavar bvi ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex ('b''v''-'?['0'-'9']*) }} {{ pp x = string (x) }} {{ pp-raw x = string (x) }}
metavar bv ::= {{ ocaml string}} {{ lex numeric }} {{ ocamllex ('#''b'['0'-'1']*)|('#''x'['0'-'9''a'-'f''A'-'F']*) }} {{ pp x = string (x) }} {{ pp-raw x = string (x) }}


% register and field names, including their surrounding | | 
metavar name ::= {{ ocaml string }} {{ lex alphanum }} {{ ocamllex '|'['0'-'9''a'-'z''A'-'Z''_']*'|' }}


indexvar j,k ::= {{ ocaml int}}

grammar

%%%%%%%%%%%%%% from ast.rs %%%%%%%%%%%%%%%%%%%
valu :: 'Val_' ::=             % the ott menhir backend doesn't support ntr ocaml homs, so we have to work around the fact that val is OCaml-reserved in a more ugly way
 | vu32 :: :: Symbolic
 | (_ bvi 64 ) :: :: I64
 | (_ bvi 128 ) :: :: I128
 | Bool ( bool ) :: :: Bool   % curiously different syntax?
 | bv :: :: Bits
 | s :: :: String
 | (_ unit ) :: :: Unit
 | (_ vec { valu1 , .. , valuk } ) :: :: Vector  % guessing the concrete syntax for Rust Vec
 | (_ list { valu1 , .. , valuk } ) :: :: List
 | (_ struct  struct_element1 .. struct_elementk )  :: :: Struct
 | (_ poison ) :: :: Poison

struct_element :: '' ::=
 | ( name valu ) :: :: Struct_elem


%%%%%%%%%%%%%% from smt.rs %%%%%%%%%%%%%%%%%%%


ty :: 'Ty_' ::=
  | Bool                        :: :: Bool
  | (_ BitVec u32 )              :: :: BitVec


bool :: '' ::= 	 
  | true	 				:: ::  True
  | false					:: :: False

% the following, e.g. (eq v47 v48), is roughly the concrete syntax output by isla within the formula, but in the rest of the output it uses syntax like Eq(Var(47),Var(48)).   Can we pick one?
exp :: '' ::= 
  | vu32				:: ::  Var 
  | bv					:: ::  Bits 
%  | ? u64 u32				:: ::  Bits64
  | bool 				:: ::  Bool 
  | ( eq        exp exp' )		:: ::  Eq 
  | ( neq       exp exp' )		:: ::  Neq
  | ( and       exp exp' )		:: ::  And
  | ( or        exp  exp' )		:: ::  Or
  | ( not       exp )			:: ::  Not
  | ( bvnot     exp )			:: ::  Bvnot
  | ( bvredand  exp )			:: ::  Bvredand
  | ( bvredor	exp )			:: ::  Bvredor
  | ( bvand	exp exp' )		:: ::  Bvand
  | ( bvor	exp exp' )		:: ::  Bvor
  | ( bvxor	exp exp' )		:: ::  Bvxor
  | ( bvnand	exp exp' )		:: ::  Bvnand
  | ( bvnor	exp exp' )		:: ::  Bvnor
  | ( bvxnor	exp exp' )		:: ::  Bvxnor
  | ( bvneg	exp )			:: ::  Bvneg             
  | ( bvadd	exp exp' )		:: ::  Bvadd                     
  | ( bvsub	exp exp' )		:: ::  Bvsub                     
  | ( bvmul	exp exp' )		:: ::  Bvmul                     
  | ( bvudiv	exp exp' )		:: ::  Bvudiv            
  | ( bvsdiv	exp exp' )		:: ::  Bvsdiv            
  | ( bvurem	exp exp' )		:: ::  Bvurem            
  | ( bvsrem	exp exp' )		:: ::  Bvsrem            
  | ( bvsmod	exp exp' )		:: ::  Bvsmod            
  | ( bvult	exp exp' )		:: ::  Bvult                     
  | ( bvslt	exp exp' )		:: ::  Bvslt                     
  | ( bvule	exp exp' )		:: ::  Bvule                     
  | ( bvsle	exp exp' )		:: ::  Bvsle                     
  | ( bvuge	exp exp' )		:: ::  Bvuge                     
  | ( bvsge	exp exp' )		:: ::  Bvsge                     
  | ( bvugt	exp exp' )		:: ::  Bvugt                     
  | ( bvsgt	exp exp' )		:: ::  Bvsgt                     
  | ( (_ extract u32 u32' )  exp'' )	:: ::  Extract
  | ( (_ zero_extend u32 ) exp' )	:: ::  ZeroExtend
  | ( (_ sign_extend u32 ) exp' )	:: ::  SignExtend
  | ( bvshl  exp exp' )			:: ::  Bvshl 
  | ( bvlshr exp exp' )			:: ::  Bvlshr
  | ( bvashr exp exp' )			:: ::  Bvashr
  | ( concat exp exp' )			:: ::  Concat
  | ( ite exp exp' exp'' )		:: ::  Ite


def :: '' ::=
  | ( declare-const vu32 ty )       :: ::        DeclareConst
  | ( define-const vu32  exp )   :: ::   DefineConst
  | ( assert exp )             :: ::  Assert

%  | ( declare-const vu32 ty )       :: ::        DeclareConst
%  | ( define-const vu32 exp )   :: ::   DefineConst
%  | ( assert exp )             :: ::  Assert
%

%(write-reg |PC| (_ struct (|UAO| v20)))

%(read-reg |PSTATE| (_ field |SP|) (_ struct (|UAO| v20) (|T| v8) (|TCO| v19) (|GE| v22) (|EL| #b10) (|F| v11) (|N| v16) (|M| v17) (|J| v24) (|Z| v21) (|IL| v3) (|SS| v9) (|V| v4) (|E| v13) (|SP| v6) (|DIT| v5) (|Q| v23) (|BTYPE| v12) (|D| v0) (|C| v15) (|IT| v2) (|A| v18) (|PAN| v25) (|nRW| v7) (|SSBS| v10) (|I| v14)))

%(read-reg |PSTATE| (_ field |SP|) (_ struct (|UAO| v20) ))



accessor :: '' ::=
  | (_ field name ) :: :: Field  % in the Rust, the argument is a u32 symtab index, pretty-printed using zencode::decode(symtab.to_str(*name))).   How stable is that mapping, and do we need it to be exported?

accessor_list :: '' ::=
  | nil :: :: Nil
  | ( accessor1 .. accessork )  :: :: Cons

event :: '' ::=
%  |  Smt ( def )           :: :: Smt
  |  ( read-reg name accessor_list valu ) :: :: ReadReg
  |  ( write-reg name valu ) :: :: WriteReg
%  |  ( read-mem  { valuue: u32 , read_kind: valu, address: valu', bytes: u32' } :: :: ReadMem
%  |  WriteMem { valuue: u32 , write_kind: valu, address: valu', data: valu'', bytes: u32' } :: :: WriteMem


term :: '' ::= {{ menhir-start }}
 | def :: :: Def
 | event :: :: Event
%
%top_level :: '' ::=
 | ( formulas def1 .. defj ) ( events event1 .. eventk ) :: :: Top

% not sure how ReadMem and WriteMem will be rendered (presumably by #[derive(Clone, Debug)])

% not sure how a "Register write"and "WriteReg" in the output relate?
