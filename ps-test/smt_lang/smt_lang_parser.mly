/* generated by Ott 0.30 from: smt_lang.ott */
%{
open Smt_lang_ast
%}

%token VEC_UNDERSCORE_BOOL  (* Vec_bool *)
%token BITS_SIX_FOUR  (* Bits64 *)
%token SIGNEXTEND  (* SignExtend *)
%token ZEROEXTEND  (* ZeroExtend *)
%token BVREDAND  (* Bvredand *)
%token BVREDOR  (* Bvredor *)
%token EXTRACT  (* Extract *)
%token BITVEC  (* BitVec *)
%token BVASHR  (* Bvashr *)
%token BVLSHR  (* Bvlshr *)
%token BVNAND  (* Bvnand *)
%token BVSDIV  (* Bvsdiv *)
%token BVSMOD  (* Bvsmod *)
%token BVSREM  (* Bvsrem *)
%token BVUDIV  (* Bvudiv *)
%token BVUREM  (* Bvurem *)
%token BVXNOR  (* Bvxnor *)
%token CONCAT  (* Concat *)
%token LPAREN  (* ( *)
%token RPAREN  (* ) *)
%token BOOL1  (* Bool *)
%token BOOL2  (* bool *)
%token BVADD  (* Bvadd *)
%token BVAND  (* Bvand *)
%token BVMUL  (* Bvmul *)
%token BVNEG  (* Bvneg *)
%token BVNOR  (* Bvnor *)
%token BVNOT  (* Bvnot *)
%token BVSGE  (* Bvsge *)
%token BVSGT  (* Bvsgt *)
%token BVSHL  (* Bvshl *)
%token BVSLE  (* Bvsle *)
%token BVSLT  (* Bvslt *)
%token BVSUB  (* Bvsub *)
%token BVUGE  (* Bvuge *)
%token BVUGT  (* Bvugt *)
%token BVULE  (* Bvule *)
%token BVULT  (* Bvult *)
%token BVXOR  (* Bvxor *)
%token COMMA  (* , *)
%token BITS  (* Bits *)
%token BVOR  (* Bvor *)
%token AND  (* And *)
%token ITE  (* Ite *)
%token NEQ  (* Neq *)
%token NOT  (* Not *)
%token VAR  (* Var *)
%token EQ  (* Eq *)
%token OR  (* Or *)
%token <string> U_THREE_TWO  (* metavarroot u32 *)
%token <string> U_SIX_FOUR  (* metavarroot u64 *)
%token EOF  (* added by Ott *)

%start <Smt_lang_ast.exp> exp_start


%%

exp_start:
| exp = exp EOF
    { exp }

ty:
| BOOL1    (* Bool :: Ty_Bool *)
    { (*Case 2*) Ty_Bool }
| BITVEC  LPAREN  u32 = U_THREE_TWO  RPAREN    (* BitVec ( u32 ) :: Ty_BitVec *)
    { (*Case 2*) Ty_BitVec(u32) }

exp:
| VAR  LPAREN  u32 = U_THREE_TWO  RPAREN    (* Var ( u32 ) :: Var *)
    { (*Case 2*) Var(u32) }
| BITS  LPAREN  VEC_UNDERSCORE_BOOL  RPAREN    (* Bits ( Vec_bool ) :: Bits *)
    { (*Case 2*) Bits }
| BITS_SIX_FOUR  LPAREN  u64 = U_SIX_FOUR  COMMA  u32 = U_THREE_TWO  RPAREN    (* Bits64 ( u64 , u32 ) :: Bits64 *)
    { (*Case 2*) Bits64(u64,u32) }
| BOOL1  LPAREN  BOOL2  RPAREN    (* Bool ( bool ) :: Bool *)
    { (*Case 2*) Bool }
| EQ  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Eq ( exp , exp' ) :: Eq *)
    { (*Case 2*) Eq(exp,exp_prime) }
| NEQ  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Neq ( exp , exp' ) :: Neq *)
    { (*Case 2*) Neq(exp,exp_prime) }
| AND  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* And ( exp , exp' ) :: And *)
    { (*Case 2*) And(exp,exp_prime) }
| OR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Or ( exp , exp' ) :: Or *)
    { (*Case 2*) Or(exp,exp_prime) }
| NOT  LPAREN  exp = exp  RPAREN    (* Not ( exp ) :: Not *)
    { (*Case 2*) Not(exp) }
| BVNOT  LPAREN  exp = exp  RPAREN    (* Bvnot ( exp ) :: Bvnot *)
    { (*Case 2*) Bvnot(exp) }
| BVREDAND  LPAREN  exp = exp  RPAREN    (* Bvredand ( exp ) :: Bvredand *)
    { (*Case 2*) Bvredand(exp) }
| BVREDOR  LPAREN  exp = exp  RPAREN    (* Bvredor ( exp ) :: Bvredor *)
    { (*Case 2*) Bvredor(exp) }
| BVAND  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvand ( exp , exp' ) :: Bvand *)
    { (*Case 2*) Bvand(exp,exp_prime) }
| BVOR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvor ( exp , exp' ) :: Bvor *)
    { (*Case 2*) Bvor(exp,exp_prime) }
| BVXOR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvxor ( exp , exp' ) :: Bvxor *)
    { (*Case 2*) Bvxor(exp,exp_prime) }
| BVNAND  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvnand ( exp , exp' ) :: Bvnand *)
    { (*Case 2*) Bvnand(exp,exp_prime) }
| BVNOR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvnor ( exp , exp' ) :: Bvnor *)
    { (*Case 2*) Bvnor(exp,exp_prime) }
| BVXNOR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvxnor ( exp , exp' ) :: Bvxnor *)
    { (*Case 2*) Bvxnor(exp,exp_prime) }
| BVNEG  LPAREN  exp = exp  RPAREN    (* Bvneg ( exp ) :: Bvneg *)
    { (*Case 2*) Bvneg(exp) }
| BVADD  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvadd ( exp , exp' ) :: Bvadd *)
    { (*Case 2*) Bvadd(exp,exp_prime) }
| BVSUB  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsub ( exp , exp' ) :: Bvsub *)
    { (*Case 2*) Bvsub(exp,exp_prime) }
| BVMUL  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvmul ( exp , exp' ) :: Bvmul *)
    { (*Case 2*) Bvmul(exp,exp_prime) }
| BVUDIV  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvudiv ( exp , exp' ) :: Bvudiv *)
    { (*Case 2*) Bvudiv(exp,exp_prime) }
| BVSDIV  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsdiv ( exp , exp' ) :: Bvsdiv *)
    { (*Case 2*) Bvsdiv(exp,exp_prime) }
| BVUREM  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvurem ( exp , exp' ) :: Bvurem *)
    { (*Case 2*) Bvurem(exp,exp_prime) }
| BVSREM  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsrem ( exp , exp' ) :: Bvsrem *)
    { (*Case 2*) Bvsrem(exp,exp_prime) }
| BVSMOD  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsmod ( exp , exp' ) :: Bvsmod *)
    { (*Case 2*) Bvsmod(exp,exp_prime) }
| BVULT  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvult ( exp , exp' ) :: Bvult *)
    { (*Case 2*) Bvult(exp,exp_prime) }
| BVSLT  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvslt ( exp , exp' ) :: Bvslt *)
    { (*Case 2*) Bvslt(exp,exp_prime) }
| BVULE  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvule ( exp , exp' ) :: Bvule *)
    { (*Case 2*) Bvule(exp,exp_prime) }
| BVSLE  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsle ( exp , exp' ) :: Bvsle *)
    { (*Case 2*) Bvsle(exp,exp_prime) }
| BVUGE  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvuge ( exp , exp' ) :: Bvuge *)
    { (*Case 2*) Bvuge(exp,exp_prime) }
| BVSGE  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsge ( exp , exp' ) :: Bvsge *)
    { (*Case 2*) Bvsge(exp,exp_prime) }
| BVUGT  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvugt ( exp , exp' ) :: Bvugt *)
    { (*Case 2*) Bvugt(exp,exp_prime) }
| BVSGT  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvsgt ( exp , exp' ) :: Bvsgt *)
    { (*Case 2*) Bvsgt(exp,exp_prime) }
| EXTRACT  LPAREN  u32 = U_THREE_TWO  COMMA  u32_prime = U_THREE_TWO  COMMA  exp_prime_prime = exp  RPAREN    (* Extract ( u32 , u32' , exp'' ) :: Extract *)
    { (*Case 2*) Extract(u32,u32_prime,exp_prime_prime) }
| ZEROEXTEND  LPAREN  u32 = U_THREE_TWO  COMMA  exp_prime = exp  RPAREN    (* ZeroExtend ( u32 , exp' ) :: ZeroExtend *)
    { (*Case 2*) ZeroExtend(u32,exp_prime) }
| SIGNEXTEND  LPAREN  u32 = U_THREE_TWO  COMMA  exp_prime = exp  RPAREN    (* SignExtend ( u32 , exp' ) :: SignExtend *)
    { (*Case 2*) SignExtend(u32,exp_prime) }
| BVSHL  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvshl ( exp , exp' ) :: Bvshl *)
    { (*Case 2*) Bvshl(exp,exp_prime) }
| BVLSHR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvlshr ( exp , exp' ) :: Bvlshr *)
    { (*Case 2*) Bvlshr(exp,exp_prime) }
| BVASHR  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Bvashr ( exp , exp' ) :: Bvashr *)
    { (*Case 2*) Bvashr(exp,exp_prime) }
| CONCAT  LPAREN  exp = exp  COMMA  exp_prime = exp  RPAREN    (* Concat ( exp , exp' ) :: Concat *)
    { (*Case 2*) Concat(exp,exp_prime) }
| ITE  LPAREN  exp = exp  COMMA  exp_prime = exp  COMMA  exp_prime_prime = exp  RPAREN    (* Ite ( exp , exp' , exp'' ) :: Ite *)
    { (*Case 2*) Ite(exp,exp_prime,exp_prime_prime) }

