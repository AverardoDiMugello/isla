<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Isla Help</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Isla Help</h1>
</header>
<p><img src="isla.png" /></p>
<h2 id="about-isla">About Isla</h2>
<p>(<a href="help_standalone.html">Open this as a separate page</a>)</p>
<p>Isla is a symbolic execution engine for <a href="https://www.cl.cam.ac.uk/~pes20/sail/">Sail</a>. It executes instruction set architecture (ISA) specifications written in Sail, such as our <a href="https://github.com/rems-project/sail-arm">ARMv8 model</a> translated from ARMâ€™s <a href="https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools">machine readable specification</a>, or <a href="https://github.com/rems-project/sail-riscv">Sail RISC-V</a>.</p>
<p>Isla-axiomatic then combines these specifications with axiomatic memory models written in a subset of the cat language used by the <a href="http://diy.inria.fr/">diy tool suite</a> (and in particular the memory model simulation tool <a href="http://diy.inria.fr/doc/herd.html">herd7</a>), with an SMT solver like <a href="https://github.com/Z3Prover/z3">z3</a> (used by this web interface) or <a href="https://cvc4.github.io/">CVC4</a>.</p>
<h2 id="user-interface">User interface</h2>
<figure>
<img src="ui.png" alt="" /><figcaption>Isla user interface</figcaption>
</figure>
<ol type="1">
<li><p>The test/model dropdown provides a list of the currently open tests and their memory models. When a new litmus test or memory model definition is opened it will appear in this dropdown menu.</p></li>
<li><p>The litmus file dropdown provides options for opening litmus files and creating new litmus files. It also provides access to a pre-existing library of tests.</p></li>
<li><p>The memory model dropdown allows choosing the memory model to be used.</p></li>
<li><p>The architecture dropdown allows switching between ARMv8 mode and RISC-V mode.</p></li>
<li><p>The run test button runs the current litmus test with the selected model, showing an execution graph in (<strong>12</strong>) if the test is allowed. If the test is forbidden (or allowed) this will be shown in (<strong>9</strong>).</p></li>
<li><p>Allows setting addition options. Currently instruction fetch reads can be ignored (although they should not be ignored when using the ESOP2020 ifetch model), and it allows filtering out irf edges from the initial state in the ESOP2020 ifetch tests, as they can clutter the graph.</p></li>
<li><p>Allows creating a link to a snapshot of the interface state.</p></li>
<li><p>The concurrency litmus test, which can be edited.</p></li>
<li><p>A log of test results and feedback.</p></li>
<li><p>This tab shows the assembled machine code for the litmus test.</p></li>
<li><p>The editable memory model specified in the cat language. See below for a description of this language.</p></li>
<li><p>A graph of the execution, generated by (<strong>5</strong>). Relations can be toggled on and off by via the relations dropdown. If there are multiple valid executions, they can be switched between using the arrows in the top right.</p></li>
</ol>
<h2 id="cat-language-for-specifying-memory-models">Cat language for specifying memory models</h2>
<p>cat has some features which are not easy (or even possible at all) to translate into SMT. Roughly-speaking, we support the fragment of cat that defines sets and relations over events. More formally the fragment of cat we support is defined by the grammar:</p>
<pre><code>expr ::= 0
       | id
       | expr? | expr^-1
       | ~expr
       | [expr]
       | expr | expr
       | expr ; expr | expr \ expr | expr &amp; expr | expr * expr
       | expr expr
       | let id = expr in expr
       | ( expr )

binding ::= id = expr

closure_binding ::= id = expr^+
                  | id = expr^*

id ::= [a-zA-Z_][0-9a-z_.-]*

def ::= let binding { and binding }
      | let closure_binding
      | let funbinding
      | include string
      | show expr as id
      | show id {, id }
      | unshow id {, id }
      | [ flag ] check expr [ as id ]

funbinding ::= id ( id ) = expr

check ::= checkname | ~checkname

checkname ::= acyclic | irreflexive | empty</code></pre>
</body>
</html>
